// Copyright 2024 - See NOTICE file for copyright holders.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![cfg(test)]

use crate::get_channel_id;
use crate::{A, B};
use ed25519_dalek::Keypair;
use ed25519_dalek::Signer;
use rand::thread_rng;
use soroban_sdk::token::StellarAssetClient;
use soroban_sdk::xdr::{FromXdr, ToXdr};
use soroban_sdk::{token, Bytes, IntoVal};

use super::{Adjudicator, AdjudicatorClient, Balances, Params, Participant, State};
use crate::multi;
use k256::ecdsa::{SigningKey, VerifyingKey};
use k256::elliptic_curve::rand_core::OsRng;
use soroban_sdk::{
    testutils::{Address as _, BytesN as _, Ledger, LedgerInfo},
    Address, BytesN, Env,
};
use token::Client as TokenClient;

#[test]
fn test_signature_verification() {
    // Test if signature verifies if:
    // - participant is randomly generated by perun-stellar-backend in go
    // - participant is converted to xdr by perun-stellar-backend in go
    // - message is signed the participant's account in the perun-stellar-backend
    let t = setup(10, 100, 200, true);
    let participant_xdr: [u8; 124] = [
        0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 15, 0, 0, 0, 4, 97, 100, 100, 114, 0, 0, 0,
        18, 0, 0, 0, 0, 0, 0, 0, 0, 62, 43, 159, 246, 201, 189, 121, 97, 55, 7, 106, 6, 15, 146,
        228, 22, 5, 235, 240, 191, 42, 53, 63, 107, 164, 36, 159, 171, 150, 165, 254, 45, 0, 0, 0,
        15, 0, 0, 0, 6, 112, 117, 98, 107, 101, 121, 0, 0, 0, 0, 0, 13, 0, 0, 0, 32, 201, 49, 94,
        195, 129, 245, 22, 0, 89, 205, 13, 45, 250, 131, 225, 83, 163, 190, 226, 56, 100, 194, 155,
        18, 237, 49, 107, 96, 147, 238, 142, 12,
    ];
    let participant_xdr_bytes = Bytes::from_array(&t.env, &participant_xdr);
    let msg: [u8; 4] = [116, 101, 115, 116]; // = "test"
    let msg_bytes = Bytes::from_array(&t.env, &msg);
    let sig_xdr: [u8; 64] = [
        114, 158, 1, 5, 187, 191, 244, 105, 52, 94, 148, 255, 173, 238, 65, 162, 164, 49, 165, 197,
        205, 152, 110, 253, 10, 10, 216, 32, 21, 244, 30, 77, 72, 101, 228, 203, 243, 183, 24, 94,
        249, 76, 182, 83, 192, 60, 42, 45, 107, 216, 21, 238, 24, 80, 51, 77, 192, 108, 191, 236,
        169, 159, 59, 7,
    ];
    let sig_xdr_bytes = BytesN::<64>::from_array(&t.env, &sig_xdr);
    let p = Participant::from_xdr(&t.env, &participant_xdr_bytes).unwrap();
    match p.pubkey {
        multi::ChannelPubKey::Single(pub_key) => {
            // Verify using the single Ed25519 key
            t.env
                .crypto()
                .ed25519_verify(&pub_key, &msg_bytes, &sig_xdr_bytes);
        }
        multi::ChannelPubKey::Multi(_) => {
            // Handle cases where the public key is not a single Ed25519 key
            panic!("Cannot verify using a non-Ed25519 key in this context.");
            // Optionally, you could handle other types of keys here if applicable
        }
    }
    // t.env
    //     .crypto()
    //     .ed25519_verify(&p.pubkey, &msg_bytes, &sig_xdr_bytes);
}

#[test]
fn test_signature_verification_secp256k1() {
    // Test if signature verifies if:
    // - participant with public key is randomly generated by perun-eth-backend in go
    // - message is signed by the participant's account in the perun-eth-backend, generating a signature
    // - the generated signature, as well as the message are used to recover the participant's public key and verify that it is identical to the signer's key
    let t = setup(10, 100, 200, true);

    let msg_text: &[u8] = b"hello world";
    let msg_bytes = Bytes::from_slice(&t.env, msg_text);
    let msg_hashed = t.env.crypto().keccak256(&msg_bytes);
    let hash_bytes: [u8; 32] = msg_hashed.into();

    let prefix = b"\x19Ethereum Signed Message:\n32";
    let prefix_hash = [prefix.as_ref(), &hash_bytes[..]].concat();
    let prefixhash_slice: &[u8] = prefix_hash.as_slice();
    let prefixhash_bytes = Bytes::from_slice(&t.env, prefixhash_slice);
    let hashed_msg_with_prefix = t.env.crypto().keccak256(&prefixhash_bytes);
    let sig: [u8; 64] = [
        16, 17, 239, 225, 176, 41, 232, 223, 159, 227, 117, 129, 82, 28, 153, 222, 0, 156, 90, 210,
        67, 185, 127, 194, 165, 8, 234, 127, 220, 3, 105, 94, 18, 93, 100, 241, 189, 4, 20, 55,
        186, 7, 117, 147, 234, 132, 47, 149, 229, 167, 190, 28, 10, 24, 140, 100, 240, 13, 82, 171,
        238, 2, 111, 69,
    ]; // 28,

    let pubkey: [u8; 65] = [
        4, 102, 214, 214, 113, 6, 75, 129, 66, 93, 131, 63, 72, 125, 19, 123, 3, 101, 142, 161,
        232, 30, 54, 48, 40, 7, 153, 40, 167, 169, 110, 125, 109, 87, 40, 52, 175, 161, 196, 43,
        104, 153, 202, 94, 107, 143, 82, 133, 139, 163, 26, 53, 183, 76, 213, 126, 215, 249, 57,
        47, 254, 127, 202, 29, 189,
    ];

    // let addr: [u8; 20] = [
    //     91, 156, 28, 28, 159, 153, 112, 89, 82, 238, 86, 37, 125, 195, 117, 181, 32, 250, 55, 85,
    // ];

    let sig_bytes = BytesN::<64>::from_array(&t.env, &sig);
    let pubkey_bytes = BytesN::<65>::from_array(&t.env, &pubkey);

    let rec_id: u32 = 1;

    let recov_pubkey =
        t.env
            .crypto()
            .secp256k1_recover(&hashed_msg_with_prefix, &sig_bytes, rec_id);

    assert_eq!(recov_pubkey, pubkey_bytes);
}

#[test]
fn test_signature_verification_k256() {
    // Test if signature verifies if:
    // - participant with public key is randomly generated by perun-eth-backend in go
    // - message is signed by the participant's account in the perun-eth-backend, generating a signature
    // - the generated signature, as well as the message are used to recover the participant's public key and verify that it is identical to the signer's key
    let t = setup(10, 100, 200, true);

    let msg_text: &[u8] = b"hello world";
    let msg_bytes = Bytes::from_slice(&t.env, msg_text);
    let msg_hashed = t.env.crypto().keccak256(&msg_bytes);
    // let msg_hashed_k256: [u8; 32] = Keccak256::digest(&msg_text).into();
    // let msg_hashed = sha3::keccak256(&msg_bytes);
    let hash_bytes: [u8; 32] = msg_hashed.into();

    // assert_eq!(hash_bytes, msg_hashed_k256);

    let prefix = b"\x19Ethereum Signed Message:\n32";
    let prefix_hash = [prefix.as_ref(), &hash_bytes[..]].concat();
    let prefixhash_slice: &[u8] = prefix_hash.as_slice();
    let prefixhash_bytes = Bytes::from_slice(&t.env, prefixhash_slice);
    let hashed_msg_with_prefix = t.env.crypto().keccak256(&prefixhash_bytes);
    let sig: [u8; 64] = [
        16, 17, 239, 225, 176, 41, 232, 223, 159, 227, 117, 129, 82, 28, 153, 222, 0, 156, 90, 210,
        67, 185, 127, 194, 165, 8, 234, 127, 220, 3, 105, 94, 18, 93, 100, 241, 189, 4, 20, 55,
        186, 7, 117, 147, 234, 132, 47, 149, 229, 167, 190, 28, 10, 24, 140, 100, 240, 13, 82, 171,
        238, 2, 111, 69,
    ]; // 28,

    let pubkey: [u8; 65] = [
        4, 102, 214, 214, 113, 6, 75, 129, 66, 93, 131, 63, 72, 125, 19, 123, 3, 101, 142, 161,
        232, 30, 54, 48, 40, 7, 153, 40, 167, 169, 110, 125, 109, 87, 40, 52, 175, 161, 196, 43,
        104, 153, 202, 94, 107, 143, 82, 133, 139, 163, 26, 53, 183, 76, 213, 126, 215, 249, 57,
        47, 254, 127, 202, 29, 189,
    ];

    // let addr: [u8; 20] = [
    //     91, 156, 28, 28, 159, 153, 112, 89, 82, 238, 86, 37, 125, 195, 117, 181, 32, 250, 55, 85,
    // ];

    let sig_bytes = BytesN::<64>::from_array(&t.env, &sig);
    let pubkey_bytes = BytesN::<65>::from_array(&t.env, &pubkey);

    let rec_id: u32 = 1;

    let recov_pubkey =
        t.env
            .crypto()
            .secp256k1_recover(&hashed_msg_with_prefix, &sig_bytes, rec_id);

    assert_eq!(recov_pubkey, pubkey_bytes);
}

#[test]
fn test_honest_payment() {
    let mut t = setup(10, 100, 200, true);
    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state);

    t.client.fund(&t.state.channel_id, &A);
    t.verify_bal_contract(100);
    t.verify_bal_a(0);

    t.client.fund(&t.state.channel_id, &B);
    t.verify_bal_contract(300);
    t.verify_bal_b(0);

    t.send_to_a(100);

    t.finalize();

    t.client.close(&t.state, &t.sig_a(), &t.sig_b());
    t.verify_state(&t.state);
    t.verify_bal_contract(300);

    t.client.withdraw(&t.state.channel_id, &A);
    t.verify_bal_a(200);
    t.verify_bal_contract(100);

    t.client.withdraw(&t.state.channel_id, &B);
    t.verify_bal_b(100);
    t.verify_bal_contract(0);
}

#[test]
fn test_funding_abort() {
    let t = setup(10, 100, 200, true);

    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state);

    t.client.fund(&t.channel_id, &A);
    t.verify_bal_contract(100);
    t.verify_bal_a(0);

    t.client.abort_funding(&t.channel_id);
    t.verify_bal_contract(0);
    t.verify_bal_a(100);
}

#[test]
fn test_dispute() {
    let mut t = setup(10, 100, 200, true);
    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state);

    t.client.fund(&t.state.channel_id, &A);
    t.verify_bal_contract(100);
    t.verify_bal_a(0);

    t.client.fund(&t.state.channel_id, &B);
    t.verify_bal_contract(300);
    t.verify_bal_b(0);

    t.send_to_a(100);

    t.client.dispute(&t.state, &t.sig_a(), &t.sig_b());

    t.set_ledger_time(
        t.env.ledger().get(),
        t.env.ledger().timestamp() + t.params.challenge_duration,
    );

    t.client.force_close(&t.channel_id);
    t.verify_state(&t.state);
    t.verify_bal_contract(300);

    t.client.withdraw(&t.channel_id, &A);
    t.verify_bal_a(200);
    t.verify_bal_contract(100);

    t.client.withdraw(&t.channel_id, &B);
    t.verify_bal_b(100);
    t.verify_bal_contract(0);
}

#[test]
fn test_malicious_dispute() {
    let mut t = setup(10, 100, 200, true);
    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state);

    t.client.fund(&t.state.channel_id, &A);
    t.verify_bal_contract(100);
    t.verify_bal_a(0);

    t.client.fund(&t.state.channel_id, &B);
    t.verify_bal_contract(300);
    t.verify_bal_b(0);

    t.send_to_a(50);

    let (old_state, old_sig_a, old_sig_b) = t.state_and_sigs();

    t.send_to_a(50);

    // malicious dispute by B (registering a state in which B still had more balance)
    t.client.dispute(&old_state, &old_sig_a, &old_sig_b);
    t.verify_state(&old_state);

    // dispute with latest state by A
    t.client.dispute(&t.state, &t.sig_a(), &t.sig_b());
    t.verify_state(&t.state);

    t.set_ledger_time(
        t.env.ledger().get(),
        t.env.ledger().timestamp() + t.params.challenge_duration,
    );

    t.client.force_close(&t.state.channel_id);
    t.verify_state(&t.state);
    t.verify_bal_contract(300);

    t.client.withdraw(&t.state.channel_id, &A);
    t.verify_bal_a(200);
    t.verify_bal_contract(100);

    t.client.withdraw(&t.state.channel_id, &B);
    t.verify_bal_b(100);
    t.verify_bal_contract(0);
}

fn sign(e: &Env, signer: &Keypair, payload: &State) -> BytesN<64> {
    let mut heap = [0u8; 1000];
    let bytes = payload.clone().to_xdr(e);
    let len = bytes.len();
    bytes.copy_into_slice(&mut heap[..len as usize]);

    signer.sign(&heap[..len as usize]).to_bytes().into_val(e)
}

fn public_key(e: &Env, signer: &Keypair) -> BytesN<32> {
    signer.public.to_bytes().into_val(e)
}

fn generate_keypair() -> Keypair {
    Keypair::generate(&mut thread_rng())
}

fn setup(challenge_duration: u64, bal_a: i128, bal_b: i128, mock_auth: bool) -> Test<'static> {
    let e = Env::default();

    let ledgerinf = LedgerInfo {
        timestamp: 0,
        protocol_version: 1,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        min_temp_entry_ttl: 16,
        min_persistent_entry_ttl: 4096,
        max_entry_ttl: 6312000,
    };

    e.ledger().set(ledgerinf.clone());

    if mock_auth {
        e.mock_all_auths();
    }
    let key_alice = generate_keypair();
    let key_bob = generate_keypair();

    let key_sec_alice = SigningKey::random(&mut OsRng);

    let signing_key = SigningKey::random(&mut OsRng);
    // Derive the verifying key from the signing key
    let verifying_key = VerifyingKey::from(&signing_key);
    let pubkey_bytes: [u8; 65] = verifying_key
        .to_encoded_point(false)
        .as_bytes()
        .try_into()
        .unwrap();
    let pubkey_bytes_trimmed: [u8; 64] = pubkey_bytes[1..].try_into().unwrap();
    // let pubkey_stellarbytes =  Bytes::from_slice(&e, &pubkey_bytes);
    // let pubkey_stellarbytes_n: BytesN<65> = pubkey_stellarbytes.try_into().expect("asdfasdf");
    let pubkey_stellarbytes_n = BytesN::from_array(&e, &pubkey_bytes);
    let pubkey_trimmed_stellarbytes_n = Bytes::from_slice(&e, &pubkey_bytes); //BytesN::from_array(&e, &pubkey_bytes);

    let pubkey = multi::ChannelPubKey::Multi(pubkey_stellarbytes_n);
    let hash: [u8; 32] = e.crypto().keccak256(&pubkey_trimmed_stellarbytes_n).into();

    let addr_hash = multi::ChannelAddress::Multi(hash);

    // compare this with k256 implementation

    // let mut addr = Address([0; 20]);
    // addr.0.copy_from_slice(&hash[32 - 20..]);
    // addr
    // pubkey.

    let alice_sec = multi::Participant {
        pubkey: pubkey,
        addr: hash,
    };

    let alice = Participant {
        addr: Address::generate(&e),
        pubkey: public_key(&e, &key_alice),
    };
    let bob = Participant {
        addr: Address::generate(&e),
        pubkey: public_key(&e, &key_bob),
    };
    let admin = Address::generate(&e);

    let token_admin =
        StellarAssetClient::new(&e, &e.register_stellar_asset_contract(admin.clone()));
    TokenClient::new(&e, &token_admin.address);
    let token = TokenClient::new(&e, &token_admin.address);
    token_admin.mint(&alice.addr, &bal_a);
    token_admin.mint(&bob.addr, &bal_b);
    let params = Params {
        a: alice.clone(),
        b: bob.clone(),
        nonce: BytesN::<32>::random(&e),
        challenge_duration: challenge_duration,
    };
    let channel_id = get_channel_id(&e, &params);
    let state = State {
        channel_id: channel_id.clone(),
        balances: Balances {
            token: multi::ChannelAsset::Single(token.address.clone()), //token.address.clone(),
            bal_a: bal_a,
            bal_b: bal_b,
        },
        version: 0,
        finalized: false,
    };
    let client = AdjudicatorClient::new(&e, &e.register_contract(None, Adjudicator {}));
    Test {
        env: e,
        alice,
        bob,
        key_alice,
        key_bob,
        params,
        channel_id,
        state,
        client,
        token,
    }
}

struct Test<'a> {
    env: Env,
    alice: Participant,
    bob: Participant,
    key_alice: Keypair,
    key_bob: Keypair,
    params: Params,
    channel_id: BytesN<32>,
    state: State,
    client: AdjudicatorClient<'a>,
    token: TokenClient<'a>,
}

impl Test<'_> {
    fn verify_state(&self, state: &State) {
        let c = self.client.get_channel(&state.channel_id);
        assert!(c.is_some());
        assert_eq!(
            &self.client.get_channel(&state.channel_id).unwrap().state,
            state
        );
    }

    fn update(&mut self, new_state: State) {
        self.state = new_state.clone();
    }

    fn sign_state(&self, state: &State) -> (BytesN<64>, BytesN<64>) {
        let sig_a = sign(&self.env, &self.key_alice, &state);
        let sig_b = sign(&self.env, &self.key_bob, &state);
        (sig_a, sig_b)
    }

    fn send_to_a(&mut self, amt: i128) {
        self.update(State {
            channel_id: self.state.channel_id.clone(),
            balances: Balances {
                token: self.state.balances.token.clone(),
                bal_a: self.state.balances.bal_a + amt,
                bal_b: self.state.balances.bal_b - amt,
            },
            version: self.state.version + 1,
            finalized: self.state.finalized,
        })
    }

    fn send_to_b(&mut self, amt: i128) {
        self.update(State {
            channel_id: self.state.channel_id.clone(),
            balances: Balances {
                token: self.state.balances.token.clone(),
                bal_a: self.state.balances.bal_a - amt,
                bal_b: self.state.balances.bal_b + amt,
            },
            version: self.state.version + 1,
            finalized: self.state.finalized,
        })
    }

    fn finalize(&mut self) {
        self.update(State {
            version: self.state.version + 1,
            finalized: true,
            ..self.state.clone()
        })
    }

    fn sig_a(&self) -> BytesN<64> {
        sign(&self.env, &self.key_alice, &self.state)
    }

    fn sig_b(&self) -> BytesN<64> {
        sign(&self.env, &self.key_bob, &self.state)
    }

    fn sigs(&self) -> (BytesN<64>, BytesN<64>) {
        (self.sig_a(), self.sig_b())
    }

    fn verify_bal_a(&self, bal: i128) {
        assert_eq!(self.token.balance(&self.alice.addr), bal);
    }

    fn verify_bal_b(&self, bal: i128) {
        assert_eq!(self.token.balance(&self.bob.addr), bal);
    }

    fn verify_bal_contract(&self, bal: i128) {
        assert_eq!(self.token.balance(&self.client.address), bal);
    }

    fn set_ledger_time(&mut self, params: LedgerInfo, new_time: u64) {
        self.env.ledger().set(LedgerInfo {
            timestamp: new_time,
            ..params
        });
    }

    fn state_and_sigs(&self) -> (State, BytesN<64>, BytesN<64>) {
        (self.state.clone(), self.sig_a(), self.sig_b())
    }
}
