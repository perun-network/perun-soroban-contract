// Copyright 2025 - See NOTICE file for copyright holders.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![cfg(test)]

use alloy_primitives::{address, keccak256, Address as EthAddr};

use crate::ethsig::ethsig::EthSigner;
use crate::sol::get_channel_id_cross;

use crate::ethsig::ethsig::EthHash;
use crate::{convert_state};
use crate::{A, B};
use alloy_sol_types::SolValue;
use k256::ecdsa::{SigningKey, VerifyingKey};
use k256::elliptic_curve::sec1::ToEncodedPoint;
use rand::thread_rng;
use soroban_sdk::token::StellarAssetClient;
use soroban_sdk::{token, Bytes};

use super::{Adjudicator, AdjudicatorClient, Balances, Params, Participant, State};
use crate::multi;
use soroban_sdk::{
    testutils::{Address as _, BytesN as _, Ledger, LedgerInfo},
    vec, Address, BytesN, Env, Vec,
};
use token::Client as TokenClient;

/// STELLAR_BACKEND_IDX is the identifier for stellar specific participants or assets.
const STELLAR_BACKEND_IDX: u64 = 2;

#[test]
fn test_signature_verification_secp256k1() {
    // Test if Eth-backend-generated signature verifies if:
    // - participant with public key is randomly generated by perun-eth-backend in go
    // - message is signed by the participant's account in the perun-eth-backend, generating a signature
    // - the generated signature, as well as the message are used to recover the participant's public key and verify that it is identical to the signer's key
    let env = Env::default();

    let mut bal_a = vec![&env];
    bal_a.push_back(100_i128);
    bal_a.push_back(150_i128);

    let mut bal_b = vec![&env];
    bal_b.push_back(200_i128);
    bal_b.push_back(250_i128);

    let t = setup(&env, 10, bal_a, bal_b, true, false);

    let msg_text: &[u8] = b"hello world";
    let msg_bytes = Bytes::from_slice(&t.env, msg_text);
    let msg_hashed = t.env.crypto().keccak256(&msg_bytes);
    let hash_bytes: [u8; 32] = msg_hashed.into();

    let prefix = b"\x19Ethereum Signed Message:\n32";
    let prefix_hash = [prefix.as_ref(), &hash_bytes[..]].concat();
    let prefixhash_slice: &[u8] = prefix_hash.as_slice();
    let prefixhash_bytes = Bytes::from_slice(&t.env, prefixhash_slice);
    let hashed_msg_with_prefix = t.env.crypto().keccak256(&prefixhash_bytes);
    let sig: [u8; 64] = [
        16, 17, 239, 225, 176, 41, 232, 223, 159, 227, 117, 129, 82, 28, 153, 222, 0, 156, 90, 210,
        67, 185, 127, 194, 165, 8, 234, 127, 220, 3, 105, 94, 18, 93, 100, 241, 189, 4, 20, 55,
        186, 7, 117, 147, 234, 132, 47, 149, 229, 167, 190, 28, 10, 24, 140, 100, 240, 13, 82, 171,
        238, 2, 111, 69,
    ]; // 28,

    let pubkey: [u8; 65] = [
        4, 102, 214, 214, 113, 6, 75, 129, 66, 93, 131, 63, 72, 125, 19, 123, 3, 101, 142, 161,
        232, 30, 54, 48, 40, 7, 153, 40, 167, 169, 110, 125, 109, 87, 40, 52, 175, 161, 196, 43,
        104, 153, 202, 94, 107, 143, 82, 133, 139, 163, 26, 53, 183, 76, 213, 126, 215, 249, 57,
        47, 254, 127, 202, 29, 189,
    ];

    let sig_bytes = BytesN::<64>::from_array(&t.env, &sig);
    let pubkey_bytes = BytesN::<65>::from_array(&t.env, &pubkey);

    let rec_id: u32 = 1;

    let recov_pubkey =
        t.env
            .crypto()
            .secp256k1_recover(&hashed_msg_with_prefix, &sig_bytes, rec_id);

    assert_eq!(recov_pubkey, pubkey_bytes);
}

#[test]
fn test_signature_verification_k256() {
    // Test if signature verifies if:
    // - participant with public key is randomly generated by perun-eth-backend in go
    // - message is signed by the participant's account in the perun-eth-backend, generating a signature
    // - the generated signature, as well as the message are used to recover the participant's public key and verify that it is identical to the signer's key
    let env = Env::default();
    let mut bal_a = vec![&env];
    bal_a.push_back(100_i128);
    bal_a.push_back(150_i128);

    let mut bal_b = vec![&env];
    bal_b.push_back(200_i128);
    bal_b.push_back(250_i128);

    let t = setup(&env, 10, bal_a, bal_b, true, false);

    let msg_text: &[u8] = b"hello world";
    let msg_bytes = Bytes::from_slice(&t.env, msg_text);
    let msg_hashed = t.env.crypto().keccak256(&msg_bytes);
    let hash_bytes: [u8; 32] = msg_hashed.into();

    let prefix = b"\x19Ethereum Signed Message:\n32";
    let prefix_hash = [prefix.as_ref(), &hash_bytes[..]].concat();
    let prefixhash_slice: &[u8] = prefix_hash.as_slice();
    let prefixhash_bytes = Bytes::from_slice(&t.env, prefixhash_slice);
    let hashed_msg_with_prefix = t.env.crypto().keccak256(&prefixhash_bytes);
    let sig: [u8; 64] = [
        16, 17, 239, 225, 176, 41, 232, 223, 159, 227, 117, 129, 82, 28, 153, 222, 0, 156, 90, 210,
        67, 185, 127, 194, 165, 8, 234, 127, 220, 3, 105, 94, 18, 93, 100, 241, 189, 4, 20, 55,
        186, 7, 117, 147, 234, 132, 47, 149, 229, 167, 190, 28, 10, 24, 140, 100, 240, 13, 82, 171,
        238, 2, 111, 69,
    ]; // 28,

    let pubkey: [u8; 65] = [
        4, 102, 214, 214, 113, 6, 75, 129, 66, 93, 131, 63, 72, 125, 19, 123, 3, 101, 142, 161,
        232, 30, 54, 48, 40, 7, 153, 40, 167, 169, 110, 125, 109, 87, 40, 52, 175, 161, 196, 43,
        104, 153, 202, 94, 107, 143, 82, 133, 139, 163, 26, 53, 183, 76, 213, 126, 215, 249, 57,
        47, 254, 127, 202, 29, 189,
    ];

    let sig_bytes = BytesN::<64>::from_array(&t.env, &sig);
    let pubkey_bytes = BytesN::<65>::from_array(&t.env, &pubkey);

    let rec_id: u32 = 1;

    let recov_pubkey =
        t.env
            .crypto()
            .secp256k1_recover(&hashed_msg_with_prefix, &sig_bytes, rec_id);

    assert_eq!(recov_pubkey, pubkey_bytes);
}

#[test]
fn test_honest_payment_cross_sameasset() {
    let env = Env::default();
    let mut bal_a = vec![&env];
    let one_withdrawer = false;

    let bal_contract_after_afund = vec![&env, 100, 150];
    let bal_contract_after_bfund = vec![&env, 300, 400];
    let bal_contract_after_awdraw = vec![&env, 200, 200];
    let bal_contract_after_bwdraw = vec![&env, 0, 0];
    let bal_contract_after_final = vec![&env, 300, 400];
    let bal_a_after_afund = vec![&env, 0, 0];
    let bal_a_after_awdraw = vec![&env, 100, 200];
    let bal_b_after_bfund = vec![&env, 0, 0];
    let bal_b_after_bwdraw = vec![&env, 200, 200];
    let to_send_a = vec![&env, 0, 50];

    bal_a.push_back(100_i128);
    bal_a.push_back(150_i128);

    let mut bal_b = vec![&env];
    bal_b.push_back(200_i128);
    bal_b.push_back(250_i128);

    let mixed_assets = false;

    let mut t = setup(&env, 10, bal_a, bal_b, true, mixed_assets);
    let stellar_channel_id = t.state.channel_id.clone();

    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state, &stellar_channel_id);

    t.client.fund(&stellar_channel_id, &A);
    t.verify_bal_contract(bal_contract_after_afund);
    t.verify_bal_a(bal_a_after_afund);

    t.client.fund(&stellar_channel_id, &B);
    t.verify_bal_contract(bal_contract_after_bfund);
    t.verify_bal_b(bal_b_after_bfund);

    t.send_to_a(to_send_a);

    t.finalize();

    let sig_a_stellar = t.sigs_ccabi_a();
    let sig_b_stellar = t.sigs_ccabi_b();

    t.client.close(&t.state, &sig_a_stellar, &sig_b_stellar);
    t.verify_state(&t.state, &stellar_channel_id);
    t.verify_bal_contract(bal_contract_after_final);

    t.client.withdraw(&stellar_channel_id, &A, &one_withdrawer);
    t.verify_bal_a(bal_a_after_awdraw);
    t.verify_bal_contract(bal_contract_after_awdraw);

    t.client.withdraw(&stellar_channel_id, &B, &one_withdrawer);
    t.verify_bal_b(bal_b_after_bwdraw);
    t.verify_bal_contract(bal_contract_after_bwdraw);
}

#[test]
fn test_honest_payment_cross_mixedssets() {
    let env = Env::default();
    let mut bal_a = vec![&env];
    let one_withdrawer = false;

    let bal_contract_after_afund = vec![&env, 100, 150];
    let bal_contract_after_bfund = vec![&env, 300, 400];
    let bal_contract_after_awdraw = vec![&env, 200, 200];
    let bal_contract_after_bwdraw = vec![&env, 0, 0];
    let bal_contract_after_final = vec![&env, 300, 400];
    let bal_a_after_afund = vec![&env, 0, 0];
    let bal_a_after_awdraw = vec![&env, 100, 200];
    let bal_b_after_bfund = vec![&env, 0, 0];
    let bal_b_after_bwdraw = vec![&env, 200, 200];
    let to_send_a = vec![&env, 0, 50];

    bal_a.push_back(100_i128);
    bal_a.push_back(150_i128);

    let mut bal_b = vec![&env];
    bal_b.push_back(200_i128);
    bal_b.push_back(250_i128);

    let mixed_assets = true;

    let mut t = setup(&env, 10, bal_a, bal_b, true, mixed_assets);
    let stellar_channel_id = t.state.channel_id.clone();

    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state, &stellar_channel_id);

    t.client.fund(&stellar_channel_id, &A);
    t.verify_bal_contract(bal_contract_after_afund);
    t.verify_bal_a(bal_a_after_afund);

    t.client.fund(&stellar_channel_id, &B);
    t.verify_bal_contract(bal_contract_after_bfund);
    t.verify_bal_b(bal_b_after_bfund);

    t.send_to_a(to_send_a);

    t.finalize();

    let sig_a_stellar = t.sigs_ccabi_a();
    let sig_b_stellar = t.sigs_ccabi_b();
    t.client.close(&t.state, &sig_a_stellar, &sig_b_stellar);
    t.verify_state(&t.state, &stellar_channel_id);
    t.verify_bal_contract(bal_contract_after_final);

    t.client.withdraw(&stellar_channel_id, &A, &one_withdrawer);
    t.verify_bal_a(bal_a_after_awdraw);
    t.verify_bal_contract(bal_contract_after_awdraw);

    t.client.withdraw(&stellar_channel_id, &B, &one_withdrawer);
    t.verify_bal_b(bal_b_after_bwdraw);
    t.verify_bal_contract(bal_contract_after_bwdraw);
}

#[test]
fn test_funding_abort_cross_sameasset() {
    let env = Env::default();

    let bal_a = vec![&env, 100, 150];
    let bal_b = vec![&env, 200, 250];

    let bal_a_after_fund = vec![&env, 0, 0];
    let bal_a_after_abort = vec![&env, 100, 150];

    let bal_contract_after_afund = vec![&env, 100, 150];
    let bal_contract_after_abort = vec![&env, 0, 0];

    let t = setup(&env, 10, bal_a, bal_b, true, false);

    let stellar_channel_id = t.state.channel_id.clone();

    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state, &stellar_channel_id);

    t.client.fund(&t.channel_id, &A);
    t.verify_bal_contract(bal_contract_after_afund);
    t.verify_bal_a(bal_a_after_fund);

    t.client.abort_funding(&t.channel_id);
    t.verify_bal_contract(bal_contract_after_abort);
    t.verify_bal_a(bal_a_after_abort);
}

#[test]
fn test_funding_abort_cross_mixedassets() {
    let env = Env::default();

    let mixed_assets = true;

    let bal_a = vec![&env, 100, 150];
    let bal_b = vec![&env, 200, 250];

    let bal_a_after_fund = vec![&env, 0, 0];
    let bal_a_after_abort = vec![&env, 100, 150];

    let bal_contract_after_afund = vec![&env, 100, 150];
    let bal_contract_after_abort = vec![&env, 0, 0];

    let t = setup(&env, 10, bal_a, bal_b, true, mixed_assets);

    let stellar_channel_id = t.state.channel_id.clone();

    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state, &stellar_channel_id);

    t.client.fund(&t.channel_id, &A);
    t.verify_bal_contract(bal_contract_after_afund);
    t.verify_bal_a(bal_a_after_fund);

    t.client.abort_funding(&t.channel_id);
    t.verify_bal_contract(bal_contract_after_abort);
    t.verify_bal_a(bal_a_after_abort);
}

#[test]
fn test_dispute_cross_sameasset() {
    let env = Env::default();
    let one_withdrawer = false;

    let bal_contract_after_afund = vec![&env, 100, 150];
    let bal_contract_after_bfund = vec![&env, 300, 400];
    let bal_a_after_wdraw = vec![&env, 100, 200];
    let bal_b_after_wdraw = vec![&env, 200, 200];
    let bal_a_after_afund = vec![&env, 0, 0];
    let bal_b_after_bfund = vec![&env, 0, 0];
    let to_send_a = vec![&env, 0, 50];

    let bal_a = vec![&env, 100, 150];
    let bal_b = vec![&env, 200, 250];

    let bal_contract_after_fclose = vec![&env, 300, 400];
    let bal_contract_after_awdraw = vec![&env, 200, 200];
    let bal_contract_after_bwdraw = vec![&env, 0, 0];
    let mut t = setup(&env, 10, bal_a, bal_b, true, false);

    let stellar_channel_id = t.state.channel_id.clone();

    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state, &stellar_channel_id);

    t.client.fund(&t.state.channel_id, &A);
    t.verify_bal_contract(bal_contract_after_afund);
    t.verify_bal_a(bal_a_after_afund);

    t.client.fund(&t.state.channel_id, &B);
    t.verify_bal_contract(bal_contract_after_bfund);
    t.verify_bal_b(bal_b_after_bfund);

    t.send_to_a(to_send_a);

    let sig_a_stellar = t.sigs_ccabi_a();
    let sig_b_stellar = t.sigs_ccabi_b();

    t.client.dispute(&t.state, &sig_a_stellar, &sig_b_stellar);

    t.set_ledger_time(
        t.env.ledger().get(),
        t.env.ledger().timestamp() + t.params.challenge_duration,
    );

    t.client.force_close(&t.channel_id);
    t.verify_state(&t.state, &stellar_channel_id);
    t.verify_bal_contract(bal_contract_after_fclose);

    t.client.withdraw(&t.channel_id, &A, &one_withdrawer);
    t.verify_bal_a(bal_a_after_wdraw);
    t.verify_bal_contract(bal_contract_after_awdraw);

    t.client.withdraw(&t.channel_id, &B, &one_withdrawer);
    t.verify_bal_b(bal_b_after_wdraw);
    t.verify_bal_contract(bal_contract_after_bwdraw);
}

#[test]
fn test_dispute_cross_mixedassets() {
    let env = Env::default();
    let one_withdrawer = false;
    let mixed_assets = true;
    let bal_contract_after_afund = vec![&env, 100, 150];
    let bal_contract_after_bfund = vec![&env, 300, 400];
    let bal_a_after_wdraw = vec![&env, 100, 200];
    let bal_b_after_wdraw = vec![&env, 200, 200];
    let bal_a_after_afund = vec![&env, 0, 0];
    let bal_b_after_bfund = vec![&env, 0, 0];
    let to_send_a = vec![&env, 0, 50];

    let bal_a = vec![&env, 100, 150];
    let bal_b = vec![&env, 200, 250];

    let bal_contract_after_fclose = vec![&env, 300, 400];
    let bal_contract_after_awdraw = vec![&env, 200, 200];
    let bal_contract_after_bwdraw = vec![&env, 0, 0];
    let mut t = setup(&env, 10, bal_a, bal_b, true, mixed_assets);

    let stellar_channel_id = t.state.channel_id.clone();

    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state, &stellar_channel_id);

    t.client.fund(&t.state.channel_id, &A);
    t.verify_bal_contract(bal_contract_after_afund);
    t.verify_bal_a(bal_a_after_afund);

    t.client.fund(&t.state.channel_id, &B);
    t.verify_bal_contract(bal_contract_after_bfund);
    t.verify_bal_b(bal_b_after_bfund);

    t.send_to_a(to_send_a);

    let sig_a_stellar = t.sigs_ccabi_a();
    let sig_b_stellar = t.sigs_ccabi_b();
    t.client.dispute(&t.state, &sig_a_stellar, &sig_b_stellar);

    t.set_ledger_time(
        t.env.ledger().get(),
        t.env.ledger().timestamp() + t.params.challenge_duration,
    );

    t.client.force_close(&t.channel_id);
    t.verify_state(&t.state, &stellar_channel_id);
    t.verify_bal_contract(bal_contract_after_fclose);

    t.client.withdraw(&t.channel_id, &A, &one_withdrawer);
    t.verify_bal_a(bal_a_after_wdraw);
    t.verify_bal_contract(bal_contract_after_awdraw);

    t.client.withdraw(&t.channel_id, &B, &one_withdrawer);
    t.verify_bal_b(bal_b_after_wdraw);
    t.verify_bal_contract(bal_contract_after_bwdraw);
}

#[test]
fn test_malicious_dispute() {
    let one_withdrawer = false;
    let env = Env::default();
    let bal_a = vec![&env, 100, 150];
    let bal_b = vec![&env, 200, 250];

    let bal_contract_after_afund = vec![&env, 100, 150];
    let bal_contract_after_bfund = vec![&env, 300, 400];
    let bal_contract_after_fclose = vec![&env, 300, 400];
    let bal_contract_after_awdraw = vec![&env, 150, 350];
    let bal_contract_after_bwdraw = vec![&env, 0, 0];

    let bal_a_after_afund = vec![&env, 0, 0];
    let bal_b_after_bfund = vec![&env, 0, 0];

    let bal_a_after_fwdraw = vec![&env, 150, 50];
    let bal_b_after_fwdraw = vec![&env, 150, 350];

    let to_send_bal_first = vec![&env, 50, 0];
    let to_send_bal_second = vec![&env, 0, 100];
    let mut t = setup(&env, 10, bal_a, bal_b, true, false);

    let stellar_channel_id = t.state.channel_id.clone();

    t.client.open(&t.params, &t.state);
    t.verify_state(&t.state, &stellar_channel_id);

    t.client.fund(&stellar_channel_id, &A);
    t.verify_bal_contract(bal_contract_after_afund);
    t.verify_bal_a(bal_a_after_afund);

    t.client.fund(&stellar_channel_id, &B);
    t.verify_bal_contract(bal_contract_after_bfund);
    t.verify_bal_b(bal_b_after_bfund);

    t.send_to_a(to_send_bal_first);

    let (old_state, old_stellar_sig_a, old_stellar_sig_b) = t.state_and_sigs_cross_abi();

    t.send_to_b(to_send_bal_second);

    // malicious dispute by B (registering a state in which B still had more balance)
    t.client
        .dispute(&old_state, &old_stellar_sig_a, &old_stellar_sig_b);
    t.verify_state(&old_state, &stellar_channel_id);

    // dispute with latest state by A
    let sig_a_stellar = t.sigs_ccabi_a();
    let sig_b_stellar = t.sigs_ccabi_b();
    t.client.dispute(&t.state, &sig_a_stellar, &sig_b_stellar);
    t.verify_state(&t.state, &stellar_channel_id);

    t.set_ledger_time(
        t.env.ledger().get(),
        t.env.ledger().timestamp() + t.params.challenge_duration,
    );

    t.client.force_close(&stellar_channel_id);
    t.verify_state(&t.state, &stellar_channel_id);
    t.verify_bal_contract(bal_contract_after_fclose);

    t.client.withdraw(&stellar_channel_id, &A, &one_withdrawer);
    t.verify_bal_a(bal_a_after_fwdraw);
    t.verify_bal_contract(bal_contract_after_awdraw);

    t.client.withdraw(&stellar_channel_id, &B, &one_withdrawer);
    t.verify_bal_b(bal_b_after_fwdraw);
    t.verify_bal_contract(bal_contract_after_bwdraw);
}

fn sign_cross_abi(e: &Env, signer: &TestKeyPair, payload: &State) -> BytesN<65> {
    let state_sol = convert_state(&e, &payload).unwrap();
    let state_sol_abi = state_sol.abi_encode();

    let state_sol_hashed = keccak256(&state_sol_abi);
    let state_sol_bytesn = BytesN::<32>::from_array(&e, &state_sol_hashed);

    let ethhash = EthHash(state_sol_bytesn.into());

    let sig1 = signer.eth_signer.sign_eth(&ethhash);
    let sig1_ethbytes = sig1.0;

    let sig1_bytes = BytesN::<65>::from_array(&e, &sig1_ethbytes);

    sig1_bytes
}

fn setup(
    e: &Env,
    challenge_duration: u64,
    bal_a: Vec<i128>,
    bal_b: Vec<i128>,
    mock_auth: bool,
    mixed_assets: bool,
) -> Test<'static> {
    let ledgerinf = LedgerInfo {
        timestamp: 0,
        protocol_version: 1,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        min_temp_entry_ttl: 16,
        min_persistent_entry_ttl: 4096,
        max_entry_ttl: 6312000,
    };

    e.ledger().set(ledgerinf.clone());

    if mock_auth {
        e.mock_all_auths();
    }

    let (alice, bob, alice_keypair, bob_keypair) = {
        let (alice_privkey, alice_pubkey) = generate_secp_keypair();
        let (bob_privkey, bob_pubkey) = generate_secp_keypair();

        let alice_keypair = EthSigner::init_from_key(alice_privkey);
        let bob_keypair = EthSigner::init_from_key(bob_privkey);

        let alice_keypair = TestKeyPair {
            eth_signer: alice_keypair,
        };
        let bob_keypair = TestKeyPair {
            eth_signer: bob_keypair,
        };

        let alice_pubkey_bytesn = get_pubkey_secp_bytesn(&e, &alice_pubkey);

        let bob_pubkey_bytesn = get_pubkey_secp_bytesn(&e, &bob_pubkey);

        let alice_l2_pubkeys = multi::ChannelPubKeyCross {
            key: alice_pubkey_bytesn.clone(),
        };

        let bob_l2_pubkeys = multi::ChannelPubKeyCross {
            key: bob_pubkey_bytesn.clone(),
        };

        let alice_bytes: [u8; 20] = [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
        ];
        let alice_eth_bytes = Bytes::from_slice(&e, &alice_bytes);

        let alice_eth_bytesn: BytesN<20> = alice_eth_bytes
            .try_into()
            .expect("some bytes for alice to have length 20 like an Ethereum address");

        let bob_eth_bytes: [u8; 20] = [
            21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        ];
        let bob_eth_bytes = Bytes::from_slice(&e, &bob_eth_bytes);
        let bob_eth_bytesn: BytesN<20> = bob_eth_bytes
            .try_into()
            .expect("some bytes for bob to have length 20 like an Ethereum address");

        let alice = Participant {
            stellar_pubkey: alice_l2_pubkeys.key,
            cc_addr: alice_eth_bytesn,
            stellar_addr: Address::generate(&e),
        };

        let bob = Participant {
            stellar_pubkey: bob_l2_pubkeys.key,
            stellar_addr: Address::generate(&e),
            cc_addr: bob_eth_bytesn,
        };

        (alice, bob, alice_keypair, bob_keypair)
    };

    if bal_a.len() != 2 {
        panic!("test setup should utilize two assets")
    }

    if bal_a.len() != bal_b.len() {
        panic!("balances arrays are not of same length");
    }
    let mut token_addresses = vec![&e];

    let mut cross_assets_0 = multi::CrossAsset {
        chain: multi::Chain::new(STELLAR_BACKEND_IDX),
        stellar_address: Address::generate(&e),
        eth_address: BytesN::<20>::from_array(&e, &[0u8; 20]),
    };

    let mut cross_assets_1 = multi::CrossAsset {
        chain: multi::Chain::new(STELLAR_BACKEND_IDX),
        stellar_address: Address::generate(&e),
        eth_address: BytesN::<20>::from_array(&e, &[0u8; 20]),
    };

    if mixed_assets == false {
        for i in 0..bal_a.len() {
            let admin_address = Address::generate(&e);
            let token_admin = StellarAssetClient::new(
                &e,
                &e.register_stellar_asset_contract(admin_address.clone()),
            );
            token_addresses.push_back(token_admin.address.clone());

            token_admin.mint(&alice.stellar_addr, &bal_a.get(i).unwrap());
            token_admin.mint(&bob.stellar_addr, &bal_b.get(i).unwrap());
        }
        cross_assets_0 = multi::CrossAsset {
            stellar_address: token_addresses.get(0).unwrap().clone(),
            chain: multi::Chain::new(STELLAR_BACKEND_IDX),
            eth_address: BytesN::<20>::from_array(&e, &[0u8; 20]),
        };

        cross_assets_1 = multi::CrossAsset {
            stellar_address: token_addresses.get(1).unwrap().clone(),
            chain: multi::Chain::new(STELLAR_BACKEND_IDX),
            eth_address: BytesN::<20>::from_array(&e, &[0u8; 20]),
        };
    }

    if mixed_assets {
        let admin_address = Address::generate(&e);
        let token_admin = StellarAssetClient::new(
            &e,
            &e.register_stellar_asset_contract(admin_address.clone()),
        );
        token_addresses.push_back(token_admin.address.clone());

        token_admin.mint(&alice.stellar_addr, &bal_a.get(0).unwrap());
        token_admin.mint(&bob.stellar_addr, &bal_b.get(0).unwrap());

        cross_assets_0 = multi::CrossAsset {
            stellar_address: token_addresses.get(0).unwrap().clone(),
            chain: multi::Chain::new(STELLAR_BACKEND_IDX),
            eth_address: BytesN::<20>::from_array(&e, &[0u8; 20]),
        };

        let checksummed = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";
        let expected = address!("d8da6bf26964af9d7eed9e03e53415d37aa96045");
        let eth_address = EthAddr::parse_checksummed(checksummed, None).expect("valid checksum");
        assert_eq!(eth_address, expected);

        let eth_addr_slice = eth_address.as_slice();
        let eth_addr_array: &[u8; 20] = eth_addr_slice
            .try_into()
            .expect("ethereum address slice is not of length 20");
        let eth_addr_bytes = BytesN::<20>::from_array(&e, eth_addr_array);

        cross_assets_1 = multi::CrossAsset {
            stellar_address: token_addresses.get(0).unwrap().clone(),
            eth_address: eth_addr_bytes,
            chain: multi::Chain::new(1),
        };
    }

    let params = Params {
        a: alice.clone(),
        b: bob.clone(),
        nonce: BytesN::<32>::random(&e),
        challenge_duration: challenge_duration,
    };

    let channel_id = get_channel_id_cross(&e, &params);

    let state = State {
        channel_id: channel_id.clone(),
        balances: Balances {
            tokens: vec![&e, cross_assets_0, cross_assets_1], //vec![&e, cross_assets_1, cross_assets_2]
            bal_a,
            bal_b,
        },
        version: 0,
        finalized: false,
    };
    let client = AdjudicatorClient::new(&e, &e.register_contract(None, Adjudicator {}));
    Test {
        env: e.clone(),
        alice,
        bob,
        alice_keypair,
        bob_keypair,
        params,
        channel_id,
        state,
        client,
        token_addresses,
    }
}

struct Test<'a> {
    env: Env,
    alice: Participant,
    bob: Participant,
    alice_keypair: TestKeyPair,
    bob_keypair: TestKeyPair,
    params: Params,
    channel_id: BytesN<32>,
    state: State,
    client: AdjudicatorClient<'a>,
    token_addresses: Vec<Address>,
}

impl Test<'_> {
    fn verify_state(&self, state: &State, channel_id: &BytesN<32>) {
        let c = self.client.get_channel(&channel_id);
        assert!(c.is_some());
        assert_eq!(&self.client.get_channel(&channel_id).unwrap().state, state);
    }

    fn update(&mut self, new_state: State) {
        self.state = new_state.clone();
    }

    fn send_to_a(&mut self, amt: Vec<i128>) {
        assert_eq!(
            self.state.balances.bal_a.len(),
            amt.len(),
            "length of bal_a and amt must be the same"
        );
        assert_eq!(
            self.state.balances.bal_b.len(),
            amt.len(),
            "length of bal_b and amt must be the same"
        );

        let mut new_bal_a = vec![&self.env];
        let mut new_bal_b = vec![&self.env];

        for i in 0..amt.len() {
            let bal_a = self.state.balances.bal_a.get(i).unwrap() + amt.get(i).unwrap();
            let bal_b = self.state.balances.bal_b.get(i).unwrap() - amt.get(i).unwrap();
            new_bal_a.push_back(bal_a);
            new_bal_b.push_back(bal_b);
        }

        self.update(State {
            channel_id: self.state.channel_id.clone(),
            balances: Balances {
                tokens: self.state.balances.tokens.clone(),
                bal_a: new_bal_a,
                bal_b: new_bal_b,
            },
            version: self.state.version + 1,
            finalized: self.state.finalized,
        })
    }

    fn send_to_b(&mut self, amt: Vec<i128>) {
        assert_eq!(
            self.state.balances.bal_a.len(),
            amt.len(),
            "length of bal_a and amt must be the same"
        );
        assert_eq!(
            self.state.balances.bal_b.len(),
            amt.len(),
            "length of bal_b and amt must be the same"
        );
        let mut new_bal_a = vec![&self.env];
        let mut new_bal_b = vec![&self.env];

        for i in 0..amt.len() {
            let bal_a = self.state.balances.bal_a.get(i).unwrap() - amt.get(i).unwrap();
            let bal_b = self.state.balances.bal_b.get(i).unwrap() + amt.get(i).unwrap();
            new_bal_a.push_back(bal_a);
            new_bal_b.push_back(bal_b);
        }

        self.update(State {
            channel_id: self.state.channel_id.clone(),
            balances: Balances {
                tokens: self.state.balances.tokens.clone(),
                bal_a: new_bal_a,
                bal_b: new_bal_b,
            },
            version: self.state.version + 1,
            finalized: self.state.finalized,
        })
    }

    fn finalize(&mut self) {
        self.update(State {
            version: self.state.version + 1,
            finalized: true,
            ..self.state.clone()
        })
    }

    fn sigs_ccabi_a(&self) -> BytesN<65> {
        sign_cross_abi(&self.env, &self.alice_keypair, &self.state)
    }

    fn sigs_ccabi_b(&self) -> BytesN<65> {
        sign_cross_abi(&self.env, &self.bob_keypair, &self.state)
    }

    fn verify_bal_a(&self, bal: Vec<i128>) {
        self.verify_bal(&self.alice.stellar_addr, bal);
    }

    fn verify_bal_b(&self, bal: Vec<i128>) {
        self.verify_bal(&self.bob.stellar_addr, bal);
    }
    fn verify_bal_contract(&self, bal: Vec<i128>) {
        for i in 0..self.token_addresses.len() {
            let token_client = self.gen_token_client(i);
            assert_eq!(
                token_client.balance(&self.client.address),
                bal.get(i).unwrap()
            );
        }
    }

    fn verify_bal(&self, participant_addr: &Address, bal: Vec<i128>) {
        for i in 0..self.token_addresses.len() {
            let token_client = self.gen_token_client(i);
            assert_eq!(token_client.balance(participant_addr), bal.get(i).unwrap());
        }
    }
    fn gen_token_client(&self, idx: u32) -> TokenClient {
        let token_addr = self.token_addresses.get(idx).unwrap();

        let token_client = TokenClient::new(&self.env, &token_addr);
        return token_client;
    }

    fn set_ledger_time(&mut self, params: LedgerInfo, new_time: u64) {
        self.env.ledger().set(LedgerInfo {
            timestamp: new_time,
            ..params
        });
    }

    fn state_and_sigs_cross_abi(&self) -> (State, BytesN<65>, BytesN<65>) {
        let sig_a = self.sigs_ccabi_a();
        let sig_b = self.sigs_ccabi_b();
        (self.state.clone(), sig_a, sig_b)
    }
}

fn generate_secp_keypair() -> (SigningKey, VerifyingKey) {
    let privkey = SigningKey::random(&mut thread_rng());
    let pubkey = VerifyingKey::from(&privkey);
    (privkey, pubkey)
}

fn get_pubkey_secp_bytesn(env: &Env, pubkey: &VerifyingKey) -> BytesN<65> {
    let pubkey_bytes: [u8; 65] = pubkey
        .to_encoded_point(false)
        .as_bytes()
        .try_into()
        .unwrap();
    let pubkey_bytesn = BytesN::from_array(env, &pubkey_bytes);
    pubkey_bytesn
}

pub struct TestKeyPair {
    pub eth_signer: EthSigner, // Only the Ethereum signer
}
